#version 450

struct Vertex {
    vec4 position;
    vec4 normal;
};

layout(std430, set = 0, binding = 0) buffer VertOut {
    Vertex[] vertices;
};
layout(std430, set = 0, binding = 1) buffer IndexOut {
    uint[] indices;
};

layout(set = 1, binding = 0) uniform texture2D ir_pixels;
layout(set = 1, binding = 1) uniform sampler ir_sampler;

layout(std140, set = 2, binding = 0)
uniform Uniforms {
    mat4 u_ir_proj;
    mat4 u_mvp;
    uint u_width;
    uint u_height;
};

vec3 pos(float x, float y) {
    vec4 pos = vec4(x/u_width, y/u_height, texture(sampler2D(ir_pixels, ir_sampler), vec2(x / u_width, (u_height - y) / u_height)).r, 1.);
    vec4 proj = u_ir_proj * pos;
    //vec4 proj = pos;
    return vec3(proj.xy, -proj.z) / proj.w;
}

vec3 norm(vec3 z, vec3 a, vec3 b) {
    return cross(a - z, b - z);
}

void main() {
    float x = float(gl_GlobalInvocationID.x);
    float y = float(gl_GlobalInvocationID.y);
    vec3 z = pos(x    , y    );
    vec3 a = pos(x    , y - 1);
    vec3 b = pos(x + 1, y - 1);
    vec3 c = pos(x + 1, y    );
    vec3 d = pos(x    , y + 1);
    vec3 e = pos(x - 1, y + 1);
    vec3 f = pos(x - 1, y    );

    vec3 sum_norm = norm(z, a, b) + norm(z, b, c) + norm(z, c, d) + norm(z, d, e) + norm(z, e, f) + norm(z, f, a);
    
    uint ux = gl_GlobalInvocationID.x;
    uint uy = gl_GlobalInvocationID.y;
    uint id = uy * u_width + ux;
    vertices[id] = Vertex(vec4(z, 1.0), vec4(normalize(sum_norm),1.0));
    if (ux < u_width - 1 && uy < u_height - 1) {
        indices[id * 6    ] = id;
        indices[id * 6 + 1] = id + 1;
        indices[id * 6 + 2] = id + u_width;
        indices[id * 6 + 3] = id + u_width;
        indices[id * 6 + 4] = id + 1;
        indices[id * 6 + 5] = id + u_width + 1;
    }

}